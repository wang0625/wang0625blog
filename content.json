{"meta":{"title":"小石头","subtitle":"选一种姿态，让自己活得无可替代","description":"世间所有的相遇，都是久别重逢","author":"小石头","url":"http://yoursite.com","root":"/"},"pages":[{"title":"All tags","date":"2019-03-25T12:03:57.000Z","updated":"2019-03-25T12:04:20.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2019-03-25T12:01:45.000Z","updated":"2019-03-25T12:02:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"How to build your own blog with GitHub + hexo","slug":"How-to-Build-a-Blog-with-Hexo","date":"2019-06-09T14:18:31.140Z","updated":"2019-04-10T13:03:50.000Z","comments":true,"path":"2019/06/09/How-to-Build-a-Blog-with-Hexo/","link":"","permalink":"http://yoursite.com/2019/06/09/How-to-Build-a-Blog-with-Hexo/","excerpt":"","text":"Welcome to 小石头 I will help you build your own blog with GitHub + hexo Quick StartIn the first place12341.安装Node.js和配置好Node.js环境2.安装Git和配置好Git环境3.Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README4.安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个Blog文件夹。(注：文件名可以自主命名） Second1234561.win+R或者单机菜单-&gt;运行，输入cmd2.输入hexo -v，检查hexo是否安装成功3.输入npm install，安装所需要的组件4.第三步完成后，找到你的hexo文件夹，鼠标右键单击你的hexo文件夹，选择Git Bash Here5.输入hexo init，请等待，这个时间可能长可能短，等到下一条可输入命令出现的时候才算安装好了，中途如果强行退出请在该文件夹重新hexo init6.鼠标右键单击你的hexo文件夹，选择Git Bash Here，进入Git命令页面，输入hexo g然后输入hexo s启东本地服务器，打开你的浏览器，输入http://localhost:4000/，你就看到你的博客样子啦！你可以在Git命令页面按住Ctrl+C来停止本地服务器。 Then将Hexo与Github page联系起来，设置Git的user name和email12345678910111.在其文件夹里面鼠标右键，点击Git Base Here,输入：git config --global user.name\"your name\"(回车)、git config --global user.email\"your email\"(回车)2.输入cd ~/.ssh，检查是否由.ssh的文件夹(回车)，输入：ls（回车）（如果出现：id_rsa id_rsa.pub known_hosts说明文件夹存在3. 输入ssh-keygen -t rsa -C “your email”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator\\.ssh）4. 输入eval \"$(ssh-agent -s)\"，添加密钥到ssh-agent, 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent5.登录Github，点击头像下的settings，添加ssh:新建一个new ssh key，将id_rsa.pub文件里的内容复制上去6.输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了7.配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo修改为： type: git repository: 你的ssh branch: master Last1231.在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save2.使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了3.部署成功后访问你的地址：https://用户名.github.io/那么将看到生成的文章 More info: 小石头","categories":[],"tags":[]},{"title":"How to create a new post","slug":"hello-world","date":"2019-06-09T14:18:31.139Z","updated":"2019-04-10T13:03:26.000Z","comments":true,"path":"2019/06/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/09/hello-world/","excerpt":"","text":"Welcome to 小石头 This is my very first post Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Base64 | Base32 | Base16编码和解码小结","slug":"Base64  Base32  Base16编码和解码小结","date":"2019-06-09T14:18:31.136Z","updated":"2019-06-10T11:14:28.181Z","comments":true,"path":"2019/06/09/Base64  Base32  Base16编码和解码小结/","link":"","permalink":"http://yoursite.com/2019/06/09/Base64  Base32  Base16编码和解码小结/","excerpt":"","text":"Welcome to 小石头! 一.Base64简介Base64是一种基于64个可打印字符来表示二进制数据的表示方法。base64编码一般有下面两个用途：1.所有的二进制文件，都可以因此转化为可打印的文本编码（都变成ASCII码可打印字符），使用文本软件进行编辑；2.能够对文本进行简单的加密 二.Base64编码规则所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符 具体来说，转换方式可以分为四步： 1.将每三个字节作为一组，一共是24个二进制位 2.将这24个二进制位分为四组，每个组有6个二进制位 3.在每组前面加两个00，扩展成32个二进制位，即四个字节 4.根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值 三.Base64编码的一个例子举一个具体的实例，演示英语单词Man如何转成Base64编码： 备注： 1.Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右 2.对于不满3个字节的东东，就需要加上base64编码中的垫字符来补充 3.Base64编码是可逆的，所以有Base64编码encode和解码decode 4.Base64主要不是加密，它主要的用途是把一些二进制数转成普通字符用于网络传输（因为一些二进制字符在传输协议中属于控制字符，不能直接传送）。另外，还有一些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。base64其实不是安全领域下的加密解密算法。虽然有时候经常看到所谓的base64加密解密。其实base64只能算是一个编码算法，对数据内容进行编码来适合传输。虽然base64编码过后原文也变成不能看到的字符格式，但是这种方式很初级，很简单 四.Base32和Base16在Base家族中还有Base32和Base16，其实Base32/Base16和Base64目的是一样的，只是具体的编码规则的不一样罢了Base32编码将二进制文件转换成由32个ASCII字符组成的文本Base16编码则将二进制文件转换成由16个字符组成的文本附上Base32编码映射表如下： More info: 小石头","categories":[],"tags":[]},{"title":"XSS攻击","slug":"XSS攻击","date":"2019-05-21T11:21:54.000Z","updated":"2019-06-10T12:11:12.798Z","comments":true,"path":"2019/05/21/XSS攻击/","link":"","permalink":"http://yoursite.com/2019/05/21/XSS攻击/","excerpt":"","text":"Welcome to 小石头 前言本小白前不久学习了关于XSS的一些小知识，在这里简单的做一些记录其次学长给推荐了一个非常有趣的XSS练习网站—–XSS平台 一、关于XSSXSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意WEB用户将代码植入到提供给其它用户使用的页面中，会使别的网站用户访问特定网页的时候来执行恶意WEB用户植入的相应代码，从而达到盗取用户资料、利用用户的身份进行某种行为，或者对访问者进行病毒侵害的一种攻击方式 二、XSS的危害包括 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 3、盗窃企业重要的具有商业价值的资料 4、非法转账 6、网站挂马 7、控制受害者机器向其它网站发起攻击 三、图像处理XSS大致可以分为三类： 1、反射型：经过后端，不经过数据库 2、存储型：经过后端，经过数据库 3、DOM：不经过后端,DOM—basedXSS漏洞是基于文档对象模型Document的一种漏洞,dom-xss是通过url传入参数去控制触发 四、文件与目录操作1、反射型： 在Notepad++上新建一个xss.html,并写入以下PHP代码： 在这串PHP代码中包含了一个表单，用于向页面发送GET请求，并且其中包含有一个名为xss的参数。 在执行的过程当中PHP会读取XSS参数，当判定XSS参数的值不为空的时候页面会自动打印出XSS参数中所包含的数据。 例如这串代码：在代码执行的过程中发现xss参数中的之后不为空，则页面会打印出XSS参数包含的值： 由此可见，这里并没有对用户传入的数据进行任何过滤，如果网站当中存在这类漏洞的情况，那么就可以通过xss来把网站的用户信息盗取出来 2.存储型： (1)在将上边的xss.php文件的内容改为（同时数据库中需要配置相应的表)： 这时我们发现用户上传的数据并没有进行处理，但是上传的数据不会直接显示在页面之中，而是插入到了数据库当中,这时如果某些用户利用这个漏洞，就可以把一些恶意代码导入其中，从而进行窃取用户数据 (2)现在新建一个名为show.php的文件，并且输入以下代码： 这串代码进去到数据库当中，并且把数据库中相应的数据打印出来 3.dom-xss： 将上边的xss.php改为： DOM-XSS 的数据流向是：URL–&gt;浏览器 总结: 在易用上，存储型XSS &gt; DOM - XSS &gt; 反射型 XSS。 PS：反射型xss和dom-xss都需要在url加入js代码才能够触发。 四、文件与目录操作. 把xss.php内容改为（同时数据库中需要配置相应的表）： 然后访问xss.php，并进行提交数据: 这时我们发现网页并没有什么特别反应，但是我们现在已经把数据插入到了数据库当中了: PS：由于操作失误插入了两项数据，但是这对于实验结果没有影响 现在就可以执行show.php来进行查询数据库里边的数据了： 存储型 XSS 的执行位置通常不同于输入位置。我们可以看出，存储行 XSS 的数据流向是： 浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。","categories":[],"tags":[]},{"title":"利用SQL注入漏洞登录后台","slug":"利用SQL注入漏洞登录后台","date":"2019-04-28T13:45:24.000Z","updated":"2019-05-07T11:12:23.439Z","comments":true,"path":"2019/04/28/利用SQL注入漏洞登录后台/","link":"","permalink":"http://yoursite.com/2019/04/28/利用SQL注入漏洞登录后台/","excerpt":"","text":"Welcome to 小石头! 前言所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击 什么时候最易受到sql注入攻击当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击。如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的 字符串来传递，也会发生sql注入。sql注入可能导致攻击者使用应用程序登陆在数据库中执行命令。如果应用程序使用特权过高的帐户连接到数据库，这种问 题会变得很严重。在某些表单中，用户输入的内容直接用来构造动态sql命令，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击。而许多 网站程序在编写时，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，使应用程序存在安全隐患。这样，用户就可以提交一段数据库查询的代码， 根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了 如何防止黑客利用SQL注入漏洞登录后台1.永远不要信任用户的输入，对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具 7.利用数据参数化来保护网页后台数据的安全 下面将要介绍如何利用数据参数化来保护数据库的安全这是未进行数据参数化处理的完整网页登录的后台验证代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); error_reporting(E_ALL ^ E_NOTICE); //初次访问 if ( ( $_POST[&apos;username&apos;] != null ) &amp;&amp; ( $_POST[&apos;password&apos;] != null ) ) &#123; $userName = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $con = mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;); if (!$con) &#123; die(&apos;数据库连接失败&apos;.$mysql_error()); &#125; mysqli_select_db($con,&quot;wang1&quot;); $sql = &quot;select * from wang2 where username = &apos;&#123;$userName&#125;&apos; &quot;; $res = mysqli_query($con,$sql); $arr = mysqli_fetch_assoc($res); if($arr)&#123; if ($arr[&apos;password&apos;] == $password) &#123; setcookie(&apos;username&apos;,$userName,time()+36000000000000000000000000000000000000000000000,&apos;/&apos;); setcookie(&apos;password&apos;,$password,time()+360000000000000000000000000000000000000000000000,&apos;/&apos;); header(&apos;Location: http://localhost/welcome1.html&apos;); &#125; else &#123; echo&quot;&lt;script&gt;alert(&apos;用户名或密码错误！&apos;);location.href = &apos;welcome2.html&apos;;&lt;/script&gt;&quot;; &#125; &#125;else&#123; echo&quot;&lt;script&gt;alert(&apos;用户名不存在！&apos;);location.href = &apos;welcome2.html&apos;;&lt;/script&gt;&quot;; &#125; &#125;else&#123; echo&quot;&lt;script&gt;alert(&apos;用户名和密码不能为空！&apos;);location.href = &apos;welcome2.html&apos;;&lt;/script&gt;&quot;; &#125; //再次访问 if ( ($_COOKIE[&apos;username&apos;]!= null)&amp;&amp;($_COOKIE[&apos;password&apos;]!= null) ) &#123; $userName = $_COOKIE[&apos;username&apos;]; $password = $_COOKIE[&apos;password&apos;]; $con = mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;ymh&apos;); $res = mysqli_query($con,&quot;select * from wang1 where username=&apos;&#123;$userName&#125;&apos;&quot;); $row = mysqli_fetch_assoc($res); if ($row[&apos;password&apos;] == $password) &#123; header(&apos;Location: welcome2.html&apos; . &quot;?username=&#123;$userName&#125;&quot;); &#125; else&#123; echo&quot;&lt;script&gt;location.href = &apos;welcome2.html&apos;;&lt;/script&gt;&quot;; &#125; &#125;?&gt; 漏洞代码图：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;img src=&quot;/picture/B22WPMKQ@NZ7@@[HU24W_YJ.png&quot;&gt;如果我们直接将用户提交过来的数据(用户名和密码)直接拿去执行，并没有实现进行特殊字符过滤，待会你们将明白，这是致命的。代码分析：如果，用户名和密码都匹配成功的话，将跳转到管理员操作界面(manager.php)，不成功，则给出友好提示信息。### 构造SQL语句 填好正确的用户名(marcofly)和密码(test)后，点击提交，将会返回给我们“欢迎管理员”的界面。 select * from users where username=&apos;marcofly&apos; and password=md5(&apos;test&apos;) 很明显，用户名和密码都和我们之前给出的一样，肯定能够成功登陆。但是，如果我们输入一个错误的用户名或密码呢?很明显，肯定登入不了吧。恩，正常情况下是如此，但是对于有SQL注入漏洞的网站来说，只要构造个特殊的“字符串”，照样能够成功登录。 比如：在用户名输入框中输入:’ or 1=1#,密码随便输入，这时候的合成后的SQL查询语句为： select * from users where username=&apos;&apos; or 1=1#&apos; and password=md5(&apos;&apos;) 语义分析：“#”在mysql中是注释符，这样井号后面的内容将被mysql视为注释内容，这样就不会去执行了，换句话说，以下的两句sql语句等价： select * from users where username=&apos;&apos; or 1=1#&apos; and password=md5(&apos;&apos;) 等价于 select * from users where username=&apos;&apos; or 1=1SQL注入采用的&apos; OR 1=1 # 是什么意思呢？最后一个#号有什么意义呢？SELECT * FROM test WHERE name=&apos;&apos; OR 1=1 #&apos; AND age=&apos;20&apos; 这后面写的 #&apos; 是什么意思呢？# 可以注释掉后面的一行SQL代码相当于去掉了一个where条件MySQL 注释, 过滤掉后面的SQL语句，使其不起作用因为1=1永远是都是成立的，即where子句总是为真，将该sql进一步简化之后，等价于如下select语句：select * from users 没错，该sql语句的作用是检索users表中的所有字段小技巧：一个经构造后的sql语句竟有如此可怕的破坏力，相信你看到这后，开始对sql注入有了一个理性的认识了吧~有漏洞的脚本才有机会给你攻击，比如一个带参数的删除脚本a.asp?action=del&amp;id=2你可以改为a.asp?action=del&amp;id=2 or 1这样就有可能删除全部数据------sql注入就是通过类似的手段来破坏数据 数据参数化解决代码漏洞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php header(&apos;content-type:text/html;charset=utf-8&apos;); error_reporting(E_ALL ^ E_NOTICE); //初次访问 if ( ( $_POST[&apos;username&apos;] != null ) &amp;&amp; ( $_POST[&apos;password&apos;] != null ) ) &#123; $userName = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $con = mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;990625&apos;); if (!$con) &#123; die(&apos;数据库连接失败&apos;.$mysql_error()); &#125; mysqli_select_db($con,&quot;wang1&quot;); $sql = &quot;select * from wang2 where username = &apos;&#123;$userName&#125;&apos; &quot;; $res = mysqli_query($con,$sql); $n=0; while($arr = mysqli_fetch_array($res)) &#123;if($arr[&apos;username&apos;]===$_POST[&apos;username&apos;]&amp;&amp;$arr[&apos;password&apos;]===$_POST[&apos;password1&apos;]) &#123;$n++; break;&#125;&#125; if($n!=0)&#123; if ($arr[&apos;password&apos;] == $password) &#123; setcookie(&apos;username&apos;,$userName,time()+36000000000000000000000000000000000000000000000,&apos;/&apos;); setcookie(&apos;password&apos;,$password,time()+360000000000000000000000000000000000000000000000,&apos;/&apos;); header(&apos;Location: https://wang0625.github.io/&apos;); &#125; else &#123; echo&quot;&lt;script&gt;alert(&apos;用户名或密码错误！&apos;);location.href = &apos;http://localhost/login.html&apos;;&lt;/script&gt;&quot;; &#125; &#125;else&#123; echo&quot;&lt;script&gt;alert(&apos;用户名不存在！&apos;);location.href = &apos;http://localhost/login.html&apos;;&lt;/script&gt;&quot;; &#125; &#125;else&#123; echo&quot;&lt;script&gt;alert(&apos;用户名和密码不能为空！&apos;);location.href = &apos;http://localhost/login.html&apos;;&lt;/script&gt;&quot;; &#125; //再次访问 if ( ($_COOKIE[&apos;username&apos;]!= null)&amp;&amp;($_COOKIE[&apos;password&apos;]!= null) ) &#123; $userName = $_COOKIE[&apos;username&apos;]; $password = $_COOKIE[&apos;password&apos;]; $con = mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;990625&apos;,&apos;ymh&apos;); $res = mysqli_query($con,&quot;select * from wang1&quot;); $n=0; while($arr = mysqli_fetch_array($res)) &#123;if($arr[&apos;username&apos;]===$_POST[&apos;username&apos;]&amp;&amp;$arr[&apos;password&apos;]===$_POST[&apos;password1&apos;]) &#123;$n++; break;&#125;&#125; if($n!=0) &#123;if ($row[&apos;password&apos;] == $password) &#123; header(&apos;Location: https://wang0625.github.io/&apos; . &quot;?username=&#123;$userName&#125;&quot;); &#125; else&#123; echo&quot;&lt;script&gt;location.href = &apos;http://localhost/login.html&apos;;&lt;/script&gt;&quot;; &#125; &#125;&#125;?&gt; 这时我们只需要把数据库中返回的数据用一个变量进行储存，然后与用户上传的的数据进行对比然后进行判，这个过程中并不直接涉及到数据库中的数据，也没有办法惊醒更改，从而保证了数据库数据的安全","categories":[],"tags":[]},{"title":"PHP学习小结 (3)","slug":"PHP学习小结 (3)","date":"2019-04-19T05:45:24.000Z","updated":"2019-06-10T11:20:56.261Z","comments":true,"path":"2019/04/19/PHP学习小结 (3)/","link":"","permalink":"http://yoursite.com/2019/04/19/PHP学习小结 (3)/","excerpt":"","text":"Welcome to 小石头 前言应惊奇队长的要求团队成员需要自学成员需要在网上自学PHP，我在网上通过孙胜利的PHP从入门到精通——含基础入门、MySQL、项目实战进行了学习 一、正则表达式12345678910111213141516171819202122232425262728293031323334353637381、正则表达式语法规则 描述了一类字符串的特征，然后通过这个特征可以配合一些特定的函数，来完成对字符串更加复杂的一系列操作！ 普通字符和特殊字符组成的一个字符串2、定界符 我们一般习惯使用正斜线\"/\"作为定界的字符,前后一致3、元字符 \\d 匹配任意一个十进制数字，等价于[0-9] \\D 匹配任意一个除十进制数字以外字符,等价于[^0-9] \\s 匹配任意一个空白字符,比如换页符、换行符、回车符、制表符、垂直制表符 \\S 匹配除空白字符以外的任何一个字符 \\w 匹配任意一个数字或字母或下划线 \\W 匹配除数字、字母、下划线以外的任意一个字符 . 匹配除换行符以外的任意一个字符 * 匹配0次、或1次、或多次其前面的字符 + 匹配1次或多次其前面的字符 ? 匹配0次或1次其前面的字符 &#123;n&#125; 表示其前面字符恰好出现n次 &#123;n,&#125; 表示其前面字符出现不少于n次 &#123;n,m&#125; 表示其前面的字符至少出现n次，最多出现m次 ^或\\A 匹配字符串开始位置 $或者\\Z 匹配字符串的结束位置 | 匹配两个或多个模式 [] 匹配方括号中的任意一个字符 [^] 匹配除方括号中字符以外的任意一个字符 () 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可以使用 \\\\数字 来代表圆括号部分所匹配到的内容！4、模式修正符 常见模式修正符 i 在和模式进行匹配时不区分大小写 m 多行匹配，如果目标字符串 中没有\"\\n\"字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响 s 如果设定了此修正符，那么.将匹配所有的字符包括换行符 U 禁止贪婪匹配 二、日期与时间123456789101112131415161718191、设置时区 date_default_timezone_set('Asia/Shanghai');//设置时区2、获取当前Unix时间戳 time()3、获取指定时间的Unix时间戳 mktime() date_default_timezone_set('Asia/Shanghai');//设置时区 $nowTime=time(); $time1=mktime(0,0,0,10,1,2014);//取得一个日期的 Unix 时间戳 echo '距离2014年国庆还有'.(($time1-$nowTime)/60/60/24).'天';4、从Unix时间戳取得时间日期信息 date()格式化一个本地时间／日期 第一个参数:必填,写上你所需要的时间日期的格式,把format 字符放在第一个参数里面会被转换成对应的信息,其他的字符还是原来的样子 date('Y-m-d G:i:s') 自定义格式化Unix时间戳 为指定的时间格式!5、获取Unix时间戳和微秒数 microtime() 返回当前 Unix 时间戳和微秒数 var_dump(microtime()); var_dump(microtime(true)); 三、图像处理123456789101112131415161718192021学前了解： 在PHP中可以通过GD库处理图像创建一个图像应该完成如下所示的四个基本步骤： 1.创建图像 2.绘制图像 3.输出图像 header函数注意点 在该函数之前，不能输出任何内容 在我们的PHP代码 的函数里面，我们使用的/开头的路径 这个/不是指 web根目录,而是操作系统的 文件的根目录! 4.释放资源设计验证码的步骤：水印缩放与裁剪 imagecopyresampled()函数 采样某个图像资源的 某一部分 到 另外一个图像资源上面去 四、文件与目录操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481、判断普通文件和目录 1.is_file()//判断给定文件名是否为一个正常的文件 2.is_dir()//判断给定文件名是否是一个目录2、文件的属性 1.file_exists()//检查文件或目录是否存在 2.filesize()//取得普通文件大小 3.is_readable()//判断给定文件名是否可读 4.is_writable()//判断给定的文件名是否可写 5.filectime()//获取文件的创建时间 6.filemtime()//获取文件的修改时间 7.fileatime()//取得文件的上次访问时间 8.stat()//获取文件大部分属性值3、目录的基本操作 1.basename()//返回路径中的文件名部分 2.dirname()//返回路径中的目录部分 3.pathinfo()//返回文件路径的信息 4.opendir()//打开目录句柄 5.readdir()//从目录句柄中读取条目,返回目录中下一个文件的文件名 6.rewinddir()//倒回目录句柄 7.closedir()//关闭目录句柄 8.mkdir()//新建目录 9.rmdir()//删除指定的空目录 10.scandir()//列出指定路径中的文件和目录4、文件的基本操作 1.fopen()//打开文件或者 URL 2.fread()//读取文件 3.fgets()//从文件指针中读取一行 4.feof()//测试文件指针是否到了文件结束的位置 5.fwrite()//写入文件 6.rewind()//倒回文件指针的位置 7.flock()//轻便的咨询文件锁定 8.ftruncate()//将文件截断到给定的长度 9.fclose()//关闭一个已打开的文件指针 10.file() //把整个文件读入一个数组中 11.copy()//拷贝文件 12.unlink()//删除文件 13.file_get_contents()//将整个文件读入一个字符串 14.file_put_contents()//将字符串写入文件中 15.rename()//重命名一个文件或目录 16.readfile()//读入一个文件并写入到输出缓冲5、文件的上传 文件的上传的过程这些细节我们是不需要管的，都是自动的，上传的文件默认是放在一个临时的目录里面的，我们要做的就是把这些临时目录 里面的文件移动到我们需要的地方就OK啦！6、文件的下载 获取文件的MIME类型 http://localhost/demo10_4/index.php 就相当于 localhost/demo10_4/a.rar","categories":[],"tags":[]},{"title":"PHP学习小结 (2)","slug":"PHP学习小结 (2)","date":"2019-04-12T05:45:24.000Z","updated":"2019-05-01T00:42:34.000Z","comments":true,"path":"2019/04/12/PHP学习小结 (2)/","link":"","permalink":"http://yoursite.com/2019/04/12/PHP学习小结 (2)/","excerpt":"","text":"Welcome to 小石头 前言应惊奇队长的要求团队成员需要自学成员需要在网上自学PHP，我在网上通过孙胜利的PHP从入门到精通——含基础入门、MySQL、项目实战进行了学习，由于这篇文章是在火车上进行编写的、打字不方便，所以基本上是用了视频教学的截图 一、自定义函数123456789101112131415function 函数名([形式参数1,形式参数2,....形式参数n])&#123; //各种PHP代码.... //...... return 表达式;//也可以不返回，如果不写那么默认返回null &#125; 函数的调用: 函数的调用需要遵循定义函数的时候写的规则，一一对应，将具体的实际参数传给定义函数时候写的形式参数！ 调用函数之后执行的过程是相对独立的，互补干扰，默认没有联系！ 执行完毕返回调用的位置继续向下执行 函数的返回值： 返回给调用者,默认返回null 函数比喻成我们现实生活中的 某个零件的制造部门！ 参数：原材料或者是这个零件的一些具体的参数！ 二、PHP变量的范围1234567891011121314151617181920212223242526272829303132331.局部变量 function test()&#123; $a=1;//局部变量$a，尽在这个函数内部有效 &#125; echo $a;2.全局变量 $i=10;//全局变量（外部变量） define('MY_NAME','孙胜利'); function test()&#123; echo MY_NAME; global $i;//声明$i为全局变量,然后再这个函数内部就可以使用$i echo $i; $a=1; &#125; test();3.静态变量 function test()&#123; static $a=10;//静态变量$a,初始化静态变量,尽在第一次调用的时候执行 echo ++$a;//当第二次执行这个函数的时候$a这个变量依然存在并且里面的也值依然存在！ &#125; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; test(); 三、参数的传递12345678910111213141.按值传递参数 默认的，我们在传递参数的时候默认使用的就是这个方式！ 对形式参数的操作，根本不是影响到实际参数(变量)的值，两者相当于没有联系! 2.按引用传递参数 按引用传递参数，相当于形式参数和实际参数指的是同一个人，只是名字不一样，对于形式参数的操作会直接影响到实际参数（变量）; 3.函数的默认参数 可以给形式参数设置默认值，设置方法很简单直接赋值即可！ 给形式参数加默认值的时候是重右往左加的，右边的必须有，才能够给左边的加！ 4.可变长度参数列表 PHP提供给我们的，可以直接使用 func_get_args(); func_get_arg(); func_num_args(); 这三个函数可以使用在我们的自定义函数内部，能够返回给我们一些关于参数的信息! 四、可变函数（变量函数）12直接把函数赋值给变量 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。 五、递归函数12345递归函数即在函数内部自己调用自己的函数。 递归函数： 1)函数在被调用的执行过程中会在内存里面分配空间用于存储临时数据，那么函数在执行过程中默认之间时没有联系的（除了 静态变量，按引用传，全局变量）。里面的变量默认都是局部变量，相互之间没有影响！ 2)递归函数，在函数的内部需要有适时结束函数运行的条件！ 六、内部（内置）函数）12345PHP提供给我我们许多现成的函数或者结构，我们可以在实际的开发中直接使用！ 还有一些函数需要开启特定地 PHP 扩展模块，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。 一些常用的内置函数或者扩展的函数，我们在后面会陆陆续续的学习到，一些不太常用的可能我们没有办法全部讲到，但是 你使用函数是用来完成功能的，说白了，你有这样的需求，才会去找对应的函数！ 七、数组类型 八、数组创建）123456789101112方法一、 变量名称[索引值]=数据; 变量名称[]=数据;//不写索引值默认是 索引数组，从0开始方法二、 变量名称=array( 索引值=&gt;数据, .......... ); 数据里面还可放数组类型的数据，同一个数组中存储任何类型的数据 多维数组： 访问数值的方法 变量名称[索引值][索引值].... 九、数组的遍历1234567891011121314遍历数组：每个都经历一遍的意思 1）for循环 用的比较少，因为有缺陷 2）foreach语句来实现遍历数组的目的 foreach(数组变量 as 变量1)&#123; //每次循环执行的语句 变量1代表当前正在经历（访问）的数据 &#125; foreach(数组变量 as 变量1=&gt;变量2)&#123; //每次循环执行的语句 变量1代表当前正在经历（访问）的数据的索引值 变量1代表当前正在经历（访问）的数据 &#125; 十、预定义超全局数组变量12345678910111213已经定义好了（存在）的变量(存放的数据的类型是数组)。 超全局：超级全局变量，作用域（有效区域）！ 传递数据（提交数据）给服务器端主要两种方式 1.get方式 比如： ?参数名=参数值&amp;参数名=参数值...... http://localhost/demo5_3/index.php?参数名=参数值 在服务器端（请求的php文件这边）可以通过$_GET来获取到 $_GET索引值为参数名，索引值对应的数据就是参数值 2.post方式 比如表单 post发送过来的！ 可以通过$_POST来获取到! 十一、处理数组的相关函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521)array_count_values $array = array(1, \"hello\", 1, \"world\", \"hello\"); $arr=array_count_values($array);//函数返回数组类型的数据 print_r($array);//原来的数组不会受到任何影响 2)array_key_exists $search_array = array('first' =&gt; 1, 'second' =&gt; 4); var_dump(array_key_exists('second',$search_array)); 3)array_search $array = array(0 =&gt; 'blue', 1 =&gt; 'red', 2 =&gt; 'green', 3 =&gt; 'red',4=&gt;15); var_dump(array_search('15', $array,true)); 4)count $array = array(0 =&gt; 'blue', 1 =&gt; 'red', 2 =&gt; 'green', 3 =&gt; 'red',4=&gt;15); var_dump(count($array)); 5)in_array $os = array(\"Mac\", \"NT\", \"Irix\", \"Linux\"); var_dump(in_array('Mac', $os)); 6)list $arr=array(60,80,100); list($sunshengli,$xiaohong,$xiaoming)=array(60,80,100); echo $sunshengli; 7)asort $students=array( 'sunshengli'=&gt;60, 'lilei'=&gt;80, 'hanmeimei'=&gt;100, 'zhangsan'=&gt;90 ); asort($students); print_r($students); 直接对数组里面的数据进行排序，第二个参数 SORT_REGULAR - 正常比较单元（不改变类型） SORT_NUMERIC - 单元被作为数字来比较 SORT_STRING - 单元被作为字符串来比较 SORT_LOCALE_STRING - 根据当前的区域（locale）设置来把单元当作字符串比较。 8)array_filter function odd($var) &#123; return($var % 2 == 1); &#125; function even($var) &#123; return($var % 2 == 0); &#125; $array1 = array(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3, \"d\"=&gt;4, \"e\"=&gt;5); $array2 = array(6, 7, 8, 9, 10, 11, 12); echo \"Odd :\\n\"; print_r(array_filter($array1, \"odd\")); echo \"Even:\\n\"; print_r(array_filter($array2, \"even\")); 十二、字符串处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687881、去除空格或其他字符函数 1）.trim $str=' abc '; var_dump($str); var_dump(trim($str)); $str='abcabcdefac'; var_dump($str); var_dump(trim($str,'bac'));//如果要去除多个字符可以连着写！2、大小写转换函数 $str='test'; var_dump($str); $str1=strtoupper($str); var_dump($str); $str='TeSt'; var_dump($str); var_dump(strtolower($str)); var_dump($str);3、字符串查找函数 1）.substr_count $str='testteste'; var_dump(substr_count($str,'te')); $text2 = 'gcdgcdgcd'; echo substr_count($text2, 'gcdgcd'); $str='testteste'; var_dump(substr_count($str,'te',1,8));//不能超出字符串 2）.strpos $str='testteste'; var_dump(strpos($str, 't1')); if(strpos($str, 't')===false)&#123; echo '没找到！'; &#125;else&#123; echo '找到啦!'; &#125; $str='testteste'; var_dump(strpos($str, 't',1)); 3).strstr $str='testteste'; var_dump($str); var_dump(strstr($str,'s')); var_dump(strstr($str,'s',true));4、字符串替换函数 1).str_replace $str=array( 'abc123abc', '123abcabc', 'abcab123c' ); var_dump($str); $str1=str_replace(array('1','2','3'),array('一','二','三'),$str,$count); echo $count; var_dump($str1);5、与html标签相关的函数 1）.htmlspecialchars $str=&lt;&lt;&lt;START &lt;p style=\"color:red;font-size:128px;\"&gt;单位确定为取得完全&lt;/p&gt;\" ' START; echo $str; echo \"\\n\"; echo htmlspecialchars($str); 2).strip_tags $str=&lt;&lt;&lt;START &lt;p style=\"color:red;font-size:128px;\"&gt;单位确定为取得完全&lt;/p&gt; &lt;div style=\"color:red;\"&gt;的武器大全我&lt;/div&gt; START; //echo $str; //echo \"\\n\"; echo strip_tags($str,\"&lt;div&gt;&lt;p&gt;\");6、字符串截取函数 1).substr $str='testdqwdwqdwqdqdwq'; echo substr($str,3,2); $str='test'; echo substr($str,-3,2);7、字符串分隔函数 1).explode $str='test,test1,test2,test3'; var_dump(explode(',',$str,2)); 2).str_split $str='test'; var_dump(str_split($str,3));","categories":[],"tags":[]},{"title":"PHP学习小结(1)","slug":"PHP学习小结 (1)","date":"2019-04-05T05:45:24.000Z","updated":"2019-06-05T11:48:29.209Z","comments":true,"path":"2019/04/05/PHP学习小结 (1)/","link":"","permalink":"http://yoursite.com/2019/04/05/PHP学习小结 (1)/","excerpt":"","text":"Welcome to 小石头 前言应惊奇队长的要求团队成员需要自学成员需要在网上自学PHP，我在网上通过孙胜利的PHP从入门到精通——含基础入门、MySQL、项目实战进行了学习，由于这篇文章是在火车上进行编写的、打字不方便，所以基本上是用了视频教学的截图 一、初识PHP脚本程序 PHP关键词 二、变量 三、变量类型 四、常量 五、算数运算符 六、逻辑运算符 七、其它运算符 八、运算符的优先级 九、PHP中的if语句 十、PHP中的switch语句 十一、PHP中的循环语句 十二、PHP中特殊的流程控制语句","categories":[],"tags":[]},{"title":"HTML基础知识","slug":"Html","date":"2019-03-29T13:45:24.000Z","updated":"2019-04-10T13:04:22.000Z","comments":true,"path":"2019/03/29/Html/","link":"","permalink":"http://yoursite.com/2019/03/29/Html/","excerpt":"","text":"Welcome to 小石头 前言1最近惊奇队长在&lt;训练营小分队_六只小鸟&gt;里发了一个关于Html、css的视频链接，现在刚学了些关于HTML的知识，于是就记录一下 什么是HTML?12345678HTML 是用来描述网页的一种语言。HTML 指的是超文本标记语言: HyperText Markup LanguageHTML 不是一种编程语言，而是一种标记语言标记语言是一套标记标签 (markup tag)HTML 使用标记标签来描述网页HTML 文档包含了HTML 标签及文本内容HTML文档也叫做 web 页面 HTML 标签12345678910111213141516171819HTML 标记标签通常被称为 HTML 标签 (HTML tag)HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;标签对中的第一个标签是开始标签，第二个标签是结束标签开始和结束标签也被称为开放标签和闭合标签&lt;标签&gt;内容&lt;/标签&gt;``` ### HTML 元素``` bash\"HTML 标签\" 和 \"HTML 元素\" 通常都是描述同样的意思.但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:HTML 元素:&lt;p&gt;这是一个段落。&lt;/p&gt; Web 浏览器123Web浏览器（如谷歌浏览器，Internet 360浏览器，Firefox等）是用于读取HTML文件，并将其作为网页显示。浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户： HTML 网页结构1下面是一个可视化的HTML页面结构： &lt;!DOCTYPE&gt; 声明&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。 网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可：1234567&lt;!DOCTYPE html&gt; &lt;!DOCTYPE HTML&gt; &lt;!doctype html&gt; &lt;!Doctype Html&gt; HTML 实例123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;实例解析:&lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=\"utf-8\"&gt; 定义网页编码格式为 utf-8。&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落 这只是我在网站上学习到最基础的的一部分，更多知识可以在HTML学习上进行学习","categories":[],"tags":[]},{"title":"CRC32爆破","slug":"CRC32爆破","date":"2019-03-28T13:45:24.000Z","updated":"2019-04-10T13:03:12.000Z","comments":true,"path":"2019/03/28/CRC32爆破/","link":"","permalink":"http://yoursite.com/2019/03/28/CRC32爆破/","excerpt":"","text":"Welcome to 小石头! 前言12最近惊奇队长在:沙漏安全上出了一道关于CRC【全称是循环冗余校验(Cyclic Redundancy Check, CRC)】的一道题，令众人百思不得其解，最后在小煤球学长的指导下得知可以利用CRC爆破，由于本人第一次遇到这种题目，就记录一下 沙漏安全 正文1CRC用来校验文件是否出错但并不能用于自动纠错，就是在后面加上一小段冗余位去检测（已用红色方框括出） 这里以破解四位CRC的压缩包为例 写一个理解之后的脚本12345678910111213141516#coding:utf-8import binasciiimport string dic=string.printable #各种打印字符crc = '''你的输入 ''' # 记得要以0x开头def CrackCrc(crc): for i in dic : for j in dic: for p in dic: for q in dic: s=i+j+p+q if crc == (binascii.crc32(s) &amp; 0xffffffff): print s 要特别注意12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (binascii.crc32(str(i)) &amp; 0xffffffff) == crc: 在 Python 2.x 的版本中，binascii.crc32 所计算出來的 CRC 值域为[-2^31, 2^31-1] 之间的有符号整数，为了要与一般CRC 结果作比对，需要将其转为无符号整数，所以加上&amp; 0xffffffff来进行转换。如果是 Python 3.x 的版本，其计算结果为 [0, 2^32-1] 间的无符号整数，因此不需额外加上&amp; 0xffffffff``` ### 下面就bugku那道多个压缩包为例，上脚本``` bash#coding:utf-8import binasciiimport string import zipfile# def tansnum(s):# return int(s, 16) 转十六进制dic=string.printabledef CrackCrc(crc): for i in dic : for j in dic: for p in dic: for q in dic: s=i+j+p+q if crc == (binascii.crc32(s) &amp; 0xffffffff): print s #return def getcrc32(): l=[] for b in range(68): file = 'out' + str(b) + '.zip' f = zipfile.ZipFile(file,'r') GetCrc = f.getinfo('data.txt') crc = GetCrc.CRC l.append(hex(crc)) return lif __name__ == \"__main__\": #c = open('out.txt', 'w') l = getcrc32() for i in l: CrackCrc(i) #c.close() 另外还有一款很好用的6位的CRC32爆破附上神器：https://github.com/theonlypwner/crc32具体使用方法：1python crc32.py reverse (0X)你的crc32密文 这里的密文记得加上0x变成16进制 即可非常迅速的爆破出对应的数据，举个例子 这个CRC32爆破一旦超过六位，爆破需要花很长的时间，沙漏安全上就有一道题，我代码跑了两个多小时，结果进度也就达到了10%，这就从另外一个角度诠释了什么叫无法破解的密码//(ㄒoㄒ)//","categories":[],"tags":[]}]}